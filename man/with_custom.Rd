% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/custom.R
\name{with_custom}
\alias{with_custom}
\alias{with_custom.grob}
\alias{with_custom.Layer}
\alias{with_custom.ggplot}
\alias{with_custom.character}
\alias{with_custom.function}
\alias{with_custom.formula}
\alias{with_custom.element}
\alias{with_custom.guide}
\title{Apply a custom filter}
\usage{
with_custom(x, filter, ...)

\method{with_custom}{grob}(
  x,
  filter,
  ...,
  background = NULL,
  id = NULL,
  include = is.null(id)
)

\method{with_custom}{Layer}(x, filter, ..., id = NULL, include = is.null(id))

\method{with_custom}{ggplot}(x, filter, ignore_background = TRUE, ...)

\method{with_custom}{character}(x, filter, ..., id = NULL, include = is.null(id))

\method{with_custom}{`function`}(x, filter, ..., id = NULL, include = is.null(id))

\method{with_custom}{formula}(x, filter, ..., id = NULL, include = is.null(id))

\method{with_custom}{element}(x, filter, ...)

\method{with_custom}{guide}(x, filter, ...)
}
\arguments{
\item{x}{A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter}

\item{filter}{A function taking a \code{nativeRaster} object as the first argument
along with whatever you pass in to \code{...}}

\item{...}{Additional arguments to \code{filter}}

\item{background}{A grob to draw below the filtered grob.}

\item{id}{An id that can be used to reference this filter somewhere else}

\item{include}{Should the filter be part of the final render}

\item{ignore_background}{Should the filter be applied to everything except
the plot background, or should the background be included.}
}
\value{
A modified \code{Layer} object
}
\description{
This function allows you to apply a custom filtering function to a layer. The
function must take a \code{nativeRaster} object as the first argument along with
any other arguments passed to \code{...}. Be aware that the raster spans the full
device size and not just the viewport currently rendered to. This is because
graphics may extend outside of the viewport depending on the clipping
settings. You can use \code{\link[=viewport_location]{viewport_location()}} to figure out which pixels in the
provided raster is part of the active viewport. Be aware that nativeRaster is
encoded in row-major order in contrast to how matrices in R are encoded.
}
\examples{
library(ggplot2)
flip_raster <- function(raster, horizontal = TRUE) {
  # Ensure row-major order
  raster_dim <- dim(raster)
  raster <- matrix(raster, nrow = raster_dim[1], byrow = TRUE)

  # Get rows and columns corresponding to viewport
  vp_loc <- viewport_location()
  cols <- seq(vp_loc['xmin'], vp_loc['xmax'])
  rows <- seq(nrow(raster) - vp_loc['ymax'], nrow(raster) - vp_loc['ymin'])

  # Flip viewport pixels
  if (horizontal) {
    raster[rows, cols] <- raster[rows, rev(cols)]
  } else {
    raster[rows, cols] <- raster[rev(rows), cols]
  }

  # Revert to column-major order
  raster <- t(raster)
  dim(raster) <- raster_dim
  class(raster) <- 'nativeRaster'
  raster
}

ggplot() +
  with_custom(
    geom_text(aes(0.5, 0.75, label = 'Flippediflop!'), size = 10),
    filter = flip_raster,
    horizontal = TRUE
  )

ggplot() +
  with_custom(
    geom_text(aes(0.5, 0.75, label = 'Flippediflop!'), size = 10, fontface = 'bold'),
    filter = flip_raster,
    horizontal = FALSE
  )

}
